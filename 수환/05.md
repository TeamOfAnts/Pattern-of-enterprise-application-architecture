# 05장 동시성

- 소프트웨어 개발에서 가장 까다로운 측면 중 하나
  - 원인을 미리 알기 어려움
  - 테스트하기도 어려움
- 트랜잭션 관리자
  - 동시성의 여러 측면을 예방하는 프레임워크 제공
- 오프라인 동시성
  - 데이터가 여러 트랜잭션에 걸쳐 조작되는 경우
  - 개발자가 직접 동시성을 관리해야 됨
- 다중 스레드를 지원하는 애플리케이션 서버 시스템에도 동시성 문제 존재

## 동시성 문제

- 손실된 업데이트
  - A가 작업하는 동안 B가 작업을 시작 & 완료 후 A가 파일을 저장하면 B가 업데이트한 내용이 사라짐
- 일관성 없는 읽기
  - 두 명이 동시 작업을 할 때 읽은 데이터의 일관성이 없음
- 동시성 프로그램의 핵심적 문제는 정확성을 충족하는 것으로는 충분하지 않으며 활동성을 충족해야 함
  - 경우에 따라선 정확성을 일정 부분 양보

## 실행 컨텍스트

- 용어
  - 요청
    - 소프트웨어가 작업하고 선택적으로 응답을 보내야 하는 외부 세계로부터의 단일 호출
  - 세션
    - 클라이언트와 서버 간에 오랫동안 실행되는 상호작용
    - 하나의 일관된 논리적 흐름으로 생각하는 일련의 요청
  - 프로세스
    - 사용하는 내부 데이터에 대한 다단계 격리를 제공하는 대규모 실행 컨텍스트
  - 스레드
    - 한 프로세스 안에서 여러 오청을 지원할 수 있음
  - 트랜잭션
    - 클라이언트가 단일 요청인 것처럼 처리하고 싶은 여러 요청을 하나로 처리할 수 있음
- 한 프로세스가 한 요청만 처리하는 방식이 흔하고 동시성 문제 예방 가능

## 격리와 불변성

- 격리
  - 격리를 통해 데이터를 분리
  - 오류 발생 가능성을 낮추는 필수 기법
- 변경 불가능한 데이터
  - 동시성 충돌 예방 가능
  - 데이터의 복사본을 사용하게 하는 것도 가능

## 낙관적 동시성 제어와 비관적 동시성 제어

- 낙관적 잠금 (충돌 감지)
  - 두 사용자가 모두 자유롭게 파일을 복사, 편집 가능
  - 충돌 시 해결 방법은 사용자가 결정 가능
- 비관적 잠금 (충돌 예방)
  - 먼저 파일 체크아웃 시 다른 사용자가 편집을 할 수 없음
  - 동시성이 제한되는 단점
- 선택의 기준
  - 충돌의 빈도와 심각도
    - 충돌이 적거나 심각하지 않다면 낙관적 잠금, 심각한 경우 비관적 잠금

### 일관성 없는 읽기 예방

- 비관적 잠금의 읽기 잠금과 쓰기 잠금을 활용하면 해결 가능
  - 읽기 잠금은 여러 명이 가질 수 있지만 그 사용자가 있으면 쓰기 잠금을 가질 수 없음
- 낙관적 잠금 시 버전 표식을 기반으로 작동
- 사용한 데이터와 단순히 읽은 데이터를 분리하면 대기를 줄일 수 있음
- 임시 읽기도 또 하나의 해결법
  - 소스코드 관리 시스템에선 종종 지원

### 교착 상태

- 서로의 자원을 원해서 다른 사용자가 완료하기 전까지 작업을 진행할 수 없음
- 해결책
  - 교착 상태 감지 소프트웨어
    - 교착 시 희생자 선택
  - 모든 잠금에 시간제한 두기
  - 작업을 시작할 때 모든 잠금을 얻도록 하는 방법
  - 사용자가 잠금을 얻는 순서에 대한 규칙을 정할 수 있음
  - 다른 사람이 원하는 잠금을 갖고 있을 시 원하는 사람이 희생자가 되는 방법
  - 여러 기법을 함께 적용할 수 있음
- 엔터프라이즈 애플리케이션 개발에는 아주 간단하고 부수적인 체계 선택 필요

## 트랜잭션

- 엔터프라이즈 애플리케이션에서 동시성을 처리하는 가장 중요한 툴
  - 시작과 끝점이 명확하게 정의된 일련의 작업
  - 관련된 모든 자원은 일관된 상태로 유지
  - 전체를 실행하거나 실행하지 않는 양자택일

### ACID

- 원자성
  - 각 작업의 단계는 모두 성공하거나 롤백
- 일관성
  - 시스템의 자원은 시작과 완료 시점에 일관성 있는 상태여야 함
- 격리성
  - 성공적으로 커밋 하기 전까지 다른 트랜잭션에서 볼 수 없어야 함
- 지속성
  - 결과는 영구적이어야 함

### 트랜잭션 리소스

- 트랜잭션으로 동시성을 제어할 수 있는 모든 대상
- 긴 트랜젝션
  - 여러 요청에 걸친 트랜젝션
- 요청 트랜젝션
  - 요청 시작 시 시작, 요청이 끝날 때 끝
- 지연 트랜잭션
  - 트랜잭션을 최대한 늦게 여는 것
  - 트랜잭션으로 소비되는 시간을 최소화
  - 트랜잭션 시작 전 동시성 제어가 안되므로 일관성 없는 읽기 문제 우려
    - 어쩔 수 없는 경우가 아니라면 잘 사용되지 않음
- 트랜잭션 시 어떤 리소스가 잠기는지 어느 정도 예상 필요
  - 테이블이 잠기면 DB의 다른 모든 작업에 영향을 미침

### 활동성을 위한 트랜잭션 격리성 저하

- 직렬화 가능 트랜잭션
  - 여러 트랜잭션을 동시에 실행해도 순서대로 실행했을 때와 동일한 결과를 얻을 수 있는 경우
- SQL 표준은 네 가지 격리 수준 정의
- 반복 가능 읽기 (repeatable read)
  - 팬텀 허용
    - 컬렉션에 여러 요소 추가 시 읽는 쪽에서 일부 요소만 볼 수 있는 현상
    - 항상 삽입된 요소에서 팬텀 발생
- 반복 불가능 읽기 (unrepeatable read)
  - 커밋 된 읽기(read committed)
  - 업데이트 이후에는 원래의 읽기를 반복할 수 없음
- 더티 읽기 (dirty read)
  - 커밋 되지 않은 읽기 (read uncommitted)
  - 다른 트랜잭션이 아직 커밋 하지 않은 데이터를 읽을 수 있음
- 어느 수준까지 위험을 감수할지 결정하고 오류와 성능 간의 적절한 균형 찾는 것이 중요

### 비즈니스 트랜잭션과 시스템 트랜잭션

- 데이터베이스 트랜잭션
  - 트랜잭션의 시작과 끝을 지정하는 명령으로 구분되는 SQL 명령의 그룹
- 비즈니스 트랜잭션
  - 로그인, 계정 선택, 이체 내역 설정, 최종 이체 과정 등을 포함
  - 시스템 트랜잭션과 동일한 ACID 제공 필요
- 긴 트랜잭션
  - DB의 동시성 요건이 중간 정도 라면 사용
  - 사용해도 괜찮다면 사용하는 것을 권장
  - 귀찮은 여러 문제 예방
  - 사용 시 DB가 주요 병목 구간이 될 수 있음
    - 애플리케이션 확장성이 제약
  - 짧은 트랜잭션으로 바꾸는 리펙터링이 어려움
- 긴 트랜잭션 사용이 어려울 땐 여러 시스템 트랜잭션 사이에서 비즈니스 트랜잭션의 ACID 특성을 지원하는 것은 개발자의 몫
  - 시스템 트랜잭션은 여전히 중요
- 원자성 지속성
  - 비즈니스 트랜잭션에서 가장 쉽게 지원할 수 있는 ACID 속성
- 격리
  - 비즈니스 트랜잭션에서 가장 적용하기 어려운 ACID 속성
  - 격리의 실패는 일관성의 실패
- 비즈니스 트랜잭션은 세션과 밀접하게 연결

## 오프라인 동시성 제어를 위한 패턴

- 모든 비즈니스 트랜잭션을 요청 하나에 연결해 시스템 트랜잭션 하나로 처리할 수 있는 게 좋음
- 낙관적 오프라인 잠금 & 비관적 오프라인 잠금
  - 낙관적 오프라인 잠금은 커밋 할 때가 돼서야 알 수 있음
  - 비관적 오프라인 잠금은 프로그래밍이 어렵고 활동성이 제한
- 굵은 입자 잠금은 객체 그룹의 동시성을 함께 관리할 수 있음

## 애플리케이션 서버 동시성

- 세션별 프로세스
  - 상태가 다른 프로세스로부터 완전히 격리
  - 리소스를 너무 많이 소비
- 요청별 프로세스
  - 일정 수의 세션을 처리하는데 훨씬 적은 수의 프로세스 사용
  - 요청이 끝나면 요청에 쓰인 리소스 반환 필요
- 요청별 스레드
  - 서버의 효율을 높일 수 있음
  - 서로 격리되지 않는 문제
  - 격리된 지역을 만들고 활용할 것
- 가장 권장되는 방식은 요청별 프로세스
  - 비용이 낮음, 피해가 제한
- 객체 풀링
  - 객체 생성 비용을 낮춤
  - 객체에 대한 접근을 동기화해야 함
