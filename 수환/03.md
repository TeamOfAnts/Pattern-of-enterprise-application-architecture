# 03장 관계형 데이터베이스 매핑

- 데이터 원본 계층의 역할은 애플리케이션이 작업을 수행하는 데 필요한 인프라의 다양한 부분과 통신하는 것

## 아키텍처 패턴

- 전체 설계에 미치는 파급효과가 크고 리팩터링 하기 어려움
- SQL 접근을 도메인 논리와는 별도로 분리하고 개별 클래스에 배치하는 것이 좋음
  - 테이블에 대한 게이트웨이
    - 행 데이터 게이트웨이
      - 쿼리가 변환하는 행마다 인스턴스 하나를 만드는 것
      - 객체지향적 사고방식
    - 레코드 집합
      - 테이블과 행의 범용 자료구조
      - 각 테이블마다 클래스가 하나만 있으면 됨
  - 애플리케이션의 나머지 부분에서는 SQL에 대해 알 필요가 없음
- 도메인 모델
  - 간단한 애플리케이션에선 테이블당 도메인 클래스 하나를 사용하며 활성 레코드 구조를 사용하는 것이 적절
  - 도메인 논리라 복잡해지면 간접성을 원하게 됨
    - 데이터 매퍼 구조를 사용해 도메인 객체와 데이터베이스 테이블 간의 매핑을 격리하는 것이 좋음
  - 적절한 패턴을 활용해 뷰/쿼리를 캡슐화하면 업데이트를 안정적으로 한 곳에 구현, 사용 가능
  - 대부분의 프로젝트에 위험성 때문에 객체지향 데이터베이스가 사용되지 않음
  - O/R 매핑 툴을 도입하는 것도 진지하게 고려해 봐야 함
    - 계층을 직접 작성하고 유지 관리하는 시간과 비용을 크게 절감할 수 있음
    - 툴을 이용하더라도 패턴들을 충분히 숙지하는 것이 좋음

## 동작 문제

- O/R 매핑의 가장 어려운 측면은 O/R 매핑의 아키텍처와 동작 측면
  - 다수의 객체를 메모리로 로드하고 수정할 때, 행을 만들고 행을 수정하는 작업을 할 때 문제가 복잡해짐
  - 객체의 일관성이 중요
- 작업 단위는 복잡성과 동시성을 해결하는 데 꼭 필요한 패턴
  - 데이터베이스에서 읽은 객체를 추적 & 업데이트
  - 데이터베이스 매핑의 컨트롤러로 작동하는 객체
- 객체를 로드할 때는 같은 객체를 두 번 로드하지 않게 주의
  - 식별자 맵을 이용해 예방
- 도메인 모델을 사용 시 DB에서 객체를 로드할 때 연관된 객체가 함께 로드되도록 구성하는 것이 일반적
  - 여러 객체가 복잡하게 상호 연결된 경우 지연 로드 등이 방법

## 데이터 읽기

- 데이터를 읽는 메서드를 검색기 메서드로 생각
  - 위치는 인터페이스 패턴에 따라 달라짐
  - 객체가 아닌 데이터베이스 기준으로 작업할 것
- 성능을 위한 규칙
  - 가급적 여러 행을 한 번에 읽기
  - 쿼리 하나로 여러 테이블을 한 번에 가져오기
    - 쿼리당 최대 3~4개의 조인을 처리하도록 최적화됨
  - 클러스터링, 세심한 인덱스 사용, 메모리 캐시 활용 등

## 구조적 매핑 패턴

### 관계 매핑

- 객체와 관계형 DB를 연결하는 처리 방법엔 차이가 있음
  - 참조 방법의 차이 발생
    - 관계형 식별자를 객체의 식별자 필드로 유지하여 해결
  - 객체는 컬렉션을 사용, 관계형은 연관 링크가 단일 값을 가져야 함
    - 객체에 컬렉션이 있을 시 원본 객체의 ID와 연결된 모든 행을 찾는 쿼리 수행
      - 대규모 시스템에서는 메타데이터 기반의 처리 방법을 찾아보는 것이 합리적
    - 컬렉션 사용 시 순서가 없는 집합을 사용하는 것도 고려
      - 순서 지정 시 성능이 크게 저하될 수 있음
    - 참조 무결성 문제
      - 위상 정렬, 테이블을 기록하는 순서를 코드에 직접 기재 등으로 해결
- 날짜 범위나 금액 객체와 같은 작은 값 객체는 DB에 별도의 테이블로 나타낼 필요가 없음
  - 객체에 포함 값으로 넣을 것
  - 대규모 시 직렬화 LOB로 저장
    - XML을 활용해 SQL 호출 안에 XPath 쿼리 식을 포함해서 해결

### 상속

- SQL에서는 상속을 처리하는 표준적인 방법이 없음
- 상속을 처리하는 세 가지 방법
  - 단일 테이블 상속
    - 공간 낭비가 있을 수 있음
    - 수정이 쉽고 조인이 필요 없는 장점이 있음
  - 구현 테이블 상속
    - 변경에 취약함
  - 클레스 테이블 상속
    - 가장 단순하게 저장하지만 여러 번 조인으로 성능이 낮음
  - 세 패턴은 상호 배타적이지 않음

## 매핑

- 가장 간단한 경우
  - 트랜잭션 스크립트, 테이블 모듈
- 도메인 모델 사용 시
  - DB 설계와 비슷한 설계를 조심
    - 도메인 논리를 간소화하는데 집중
- 개발 반복 주기를 신경 쓸 것

### 이중 매핑

- 둘 이상의 데이터 원본에서 같은 종류의 데이터를 가져와야 하는 경우
  - 원본마다 하나씩 매핑 계층을 여러 개로 만드는 것이 가장 간단함
    - 코드 중복이 심해질 수 있음
      - 매핑 스키마를 고려
        - 인메모리 스키마에서 논리적 데이터 저장소 스키마로 변환
        - 논리적 데이터 저장소 스키마에서 실제 물리적 데이터 저장소 스키마로 매핑

### 메타데이터 사용

- 메타데이터 매핑
  - 데이터베이스의 열이 객체의 필드에 매핑되는 구체적인 방법을 메타데이터 파일에 기록
  - 읽기와 쓰기 코드 정의, 자동으로 임시 조인 생성, 관계의 복잡성 적용 등 가능
  - 더 발전시키면 뷰에서 DB를 거의 볼 수 없게 하는 리포지터리를 만들 수 있음

### 데이터베이스 연결

- 대부분의 DB 인터페이스는 애플리케이션 코드와 DB 간의 링크 역할을 하는 연결 객체 사용
  - 연결 비용을 절약하기 위해 연결 풀을 많이 사용
    - 풀 사용을 캡슐화하는 방식은 아주 바람직함
  - 연결을 만드는 비용이 크든 작든 관리가 필요
    - 트랜잭션이 끝나면 즉시 닫고, 트랜잭션 사용 시 일반적으로 모든 명령을 동일한 연결에 수행
      - 연결을 확보하는 방법은 매개변수로 전달, 레지스트리를 사용
- 메모리도 사용이 끝나면 반환해야 하는 자원
  - 가비지 컬렉터는 편리하고 익숙하지만 연결의 마지막 참조가 손실된 후 상당히 시간이 지난 후에 닫힐 수 있음
- 연결은 트랜잭션과 밀접하게 관련
  - 트랜잭션 바깥에서 하는 작업은 풀링으로 해결
    - 풀링(Pooling)은 자원을 효율적으로 관리하기 위해 미리 일정량의 자원을 생성해 두고 재사용하는 기법

### 기타 주의 사항

- `select *` 사용 시 주의
  - 새 열이 추가되거나 열이 재정렬될 시 심각한 문제 발생 가능
  - 열 이름 인덱스와 사용하는 것은 괜찮음
- 열 번호 인덱스를 사용할 경우, 열이 재정렬되더라도 동기화가 깨지지 않도록 SQL 문 정의와 유사한 방식으로 결과 집합을 접근해야 함
- 정적 SQL은 충분한 가치가 있음
