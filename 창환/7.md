# 7장 - 분산 전략

## 원격 및 로컬 인터페이스

- 클래스 모델별 분산은 좋지않다.
  - 한 프로세스 내의 프로시저 호출은 극도로 빠르지만 분리된 프로세스 간의 프로시저 호출은 수십, 수백배 느리다
  - 다른 시스템에서 실행중인 프로세스에 대한 프로시저 호출은 다시 수십, 수백배가 더 느려진다
- 로컬인터페이스는 **가는 입자 인터페이스(find-grained interface)** 일때 가장 좋다.
  - 주소 클래스가 있다면 시 얻기, 도 얻기, 시 설정, 도 설정 등의 메서드가 모두 별도로 있는 것이 좋은 인터페이스다.
  - 다양한 방법으로 재정의하고 향후 설계를 확장할 수 있는 작은 조각으로 정의하는 객체지향의 일반적인 규칙을 따름
- 원격 환경에서는 가는 입자 인터페이스는 좋지 않다.
  - 메서드 호출이 느리기 때문에 시, 도, 우편번호를 한번의 호출로 얻거나 업데이트해야한다.
    - 호출 횟수 최소화를 위한 굵은 입자 인터페이스

### 객체를 분산하지 말라

- 클러스터링이 가장 적합함

## 분산이 필요한 상황

- 위처럼 클러스터링은 한계가 있을 수 있다..

1. 클라이언트 - 서버 간의 분리
2. 서버 기반 어플리케이션 소프트웨어 - 데이터베이스 간의 분리
3. 웹 시스템에서 웹서버 - 애플리케이션 서버
4. 공급업체 간의 차이로 인한 분리
5. 애플리케이션 서버 소프트웨어를 분리해야 하는 합당한 이유가 있는 경우
   1. 가능한 이런 경우를 예방해야함 (최후의 수단)

## 분산 경계를 사용한 작업

### 원격 파사드

- 내부적으로 가는 입자 객체를 사용하고 이에 대한 원격 인터페이스를 제공하는 굵은 입자 객체를 분산 경계에 배치
- 굵은 입자 인터페이스를 사용할 때의 어려움을 최소화함
- DTO

### 브로커를 통해 객체를 프로세스 간 마이그레이션 해 분산을 구현하는 방법도 있음

- db에서 lazy load 체계를 이용해 객체를 전송하는 것 - 원격 호출이 지나치게 많아지지 않게 조율하는 것이 어려움
  > 필자는 이 책에서 동기식 RPC 기반 인터페이스를 사용한다고 가정했으나 비동기식 메세지 기반 방식이 더 좋다고 생각하고있음.
  > 하지만 너무 내용이 많아져 이 책에서는 다루지 못함.
