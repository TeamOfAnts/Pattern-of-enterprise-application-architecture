# 6장 - 세션 상태

## Stateless의 가치

- 요청 간에 상태가 유지되지 않는 것
- 요청간 상태가 유지되지 않기 때문에 어떤 객체로 요청을 처리해도 관계 없어 동시에 훨씬 많은 사용자를 처리할 수 있음
  - stateful이라면 항상 같은 객체가 필요함

## 세션 상태

- 장바구니의 세부 사항은 세션 상태
- 장바구니 안의 데이터는 특정 세션에만 해당된다.

## 세션 상태를 저장하는 방법

### 클라이언트 세션 상태

- 데이터를 클라이언트에 저장한다.
  - 웹 프레젠테이션을 위한 URL 안에 데이터 인코딩
  - 쿠키
  - 웹 양식의 숨겨진 필드로 데이터 직렬화
  - 리치 클라이언트의 객체에 데이터 저장

### 서버 세션 상태

- 요청 간 데이터를 메모리에 저장하는 간단한 방법일 수 있다. - 하지만 일반적으로는 세션 상태를 직렬화된 객체같이 더 안정적으로 저장할 수 있는 매커니즘이 사용된다. - 세션Id와 직렬화된 객체가 각각 키와 값인 간단한 db 테이블일 수 있다.
  > redis같은 in-memory db같은걸 말하는건가..?

### 데이터베이스 세션 상태

- db에 테이블, 필드로 분리하고 저장하는것

### 선택

- 클라이언트 세션 상태의 경우 각 요청과 함께 세션 데이터를 전송해야함.
  - 데이터가 크면 당연히 전송데이터 양이 늘어남
  - 데이터를 제대로 암호화하지 않으면 보안적으로 위험함
- 세션 데이터는 격리해야함.
  - 실제 항공권을 예약하기 전까지 다른 사용자의 예약에 영향을 주지 않아야함.
  - 다른 세션에서는 전혀 볼 수 없다는 의미.
- 데이터베이스 세션상태를 사용할 때 데이터베이스에 저장된 레코드 데이터로부터 세션 데이터를 격리하기 위해 까다로운 작업이 필요할 수 있다.
- 사용자 수가 많은 경우 클러스터링을 도입하는 것을 고려할 수 있다.
  - 이 경우 `세션 마이그레이션` 필요한지 생각해야함
    - 세션이 길게 유지 되는 경우 서버가 처리하는 부하를 균형있게 배분 가능함
- 한 서버가 특정 세션의 모든 요청을 처리하게 하는 `서버 선호도`
  - 한 클라이언트의 모든 호출을 동일한 애플리케이션 서버로 전달함
  - 이 경우 ip 주소를 사용하는 경우가 많은데, client가 proxy를 사용하는 경우 트래픽의 상당수가 한 서버로 집중될 수 있음

#### 결론

- 데이터베이스 세션 상태
  - 데이터가 많지 않지만 유휴 사용자가 많을 경우
  - 클라이언트 강제종료, 서버 오류, 네트워크 연결 실패 등을 대처하기 쉬움
  - 매핑이 복잡할 수 있고 추가적 개발작업이 필요함
- 서버 세션 상태
  - 각 요청마다 많은 양의 데이터가 오갈때
  - 비휘발성 저장소에 백업했는지에 따라 시스템 문제에 대처 여부가 결정됨
  - 가장 쉽게 개발가능함
- 클라이언트 세션 상태 - 사용자가 정상적으로 취소하지 않고 그냥 잊어버리는 경우가 많을 때 (사용자에 대해 크게 신경 쓸 필요가 없을 경우) - 클라이언트 강제종료를 제외한 나머지 두 문제에 대처 가능함
  > 필자는 서버 세션 상태를 추천함
  >
  > - 주요 정보를 원격에 저장하면 서버 오류가 발생해도 손상되지 않음
  >
  > 세션Id를 저장하거나 세션 데이터가 아주 적을때는 클라이언트 세션 상태도 자주 이용함
  >
  > 장애조치, 클러스터링, 원격에 주요정보를 저장할 수 없거나 세션 간 격리가 문제가 아닌 경우를 제외하면 db 세션상태는 잘 사용하지 않음
